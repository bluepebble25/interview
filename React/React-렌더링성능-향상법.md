# React 렌더링 성능 향상 방법

1. React.memo(), useMemo(), useCallback()으로 메모이제이션하기
2. 자식 컴포넌트에게 props를 줄 때는 객체를 가공해서 주지 말고 그대로 주기 - 객체를 가공하면 새로운 객체가 생성되는데, 이때 주소가 바뀌면 다른 객체라고 인식해서 자식 컴포넌트가 리렌더링된다. 객체의 목록을 통채로 줘서 자식 컴포넌트가 가공하도록 하자.
3. key 값으로 index를 주지 말자.
4. debouncing과 throttling을 적용하자.

## React.memo(), useMemo()

### React.memo()

- 컴포넌트를 감싸면 props가 바뀌지 않는 한 리렌더링이 되지 않게 해준다.
- props 값이 바뀌었는지 얕은 비교를 하기 때문에, 더 상세한 비교를 원한다면 두번째 인자에 비교 함수를 전달하면 된다.
- `React.memo(MyComponent, areEqual)`
- HOC(고차 컴포넌트)이기 때문에 결과물로 컴포넌트를 반환하고, 클래스형이나 함수형 컴포넌트 모두에서 사용할 수 있다.

### useMemo()

- React.memo()와 같은 역할을 한다. 다만 hook이기 때문에 함수형 컴포넌트에서만 사용할 수 있다.
- 꼭 컴포넌트를 감쌀 때가 아니라 함수의 연산 결과를 기억할 때도 사용할 수 있다.
- `const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);`
- 첫번째 인자로는 함수(함수형 컴포넌트, 일반 함수 모두 가능)을, 두번째 인자로는 디펜던시 배열을 작성한다.

## useCallback()

- 컴포넌트가 리렌더링될때마다 컴포넌트 내부에 작성한 함수도 새로 생성되는데, 성능 향상을 위해 함수 선언을 기억하는 함수이다.
- 만약 어떤 컴포넌트를 Memo로 감쌌는데, 부모 컴포넌트로부터 내려받은 함수가 리렌더링을 이유로 새로 생성된다면, 자식 컴포넌트를 Memo로 감싼것도 소용이 없을 것이다. 이럴 때 부모 컴포넌트의 함수가 새로 생성되는 것을 방지하기 위해 useCallback()을 사용하면 리렌더링을 방지할 수 있다.

## Reference

- [[React] 렌더링 성능 최적화하는 7가지 방법 (Hooks 기준)](https://velog.io/@shin6403/React-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EB%8A%94-7%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95-Hooks-%EA%B8%B0%EC%A4%80)
